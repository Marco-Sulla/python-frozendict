from collections.abc import Hashable
from typing import NoReturn, TypeVar, overload, Type, Optional

try:
    from typing import Mapping, Sequence, Iterable, Iterator
except ImportError:
    from collections.abc import Mapping, Sequence, Iterable, Iterator

K = TypeVar("K", Hashable)
V = TypeVar("V")
KV = TypeVar("KV", K, V)
T = TypeVar("T", Mapping[K, V])

class frozendict(Mapping[K, V]):
    # Fake __init__ to describe what __new__ does:
    @overload
    def __init__(self, **kwargs: V) -> None: ...
    @overload
    def __init__(self, mapping: Mapping[K, V]) -> None: ...
    @overload
    def __init__(self, iterable: Iterable[Sequence[KV]]) -> None: ...

    # Magic Methods:
    def __getitem__(self, key: K) -> V: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[K]: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def copy(self: T) -> T: ...
    def __copy__(self: T) -> T: ...
    def __deepcopy__(self: T) -> T: ...
    # Omit __reduce__, its used for Pickle and we don't need the annotation in code.
    def set(self: T, key: K, value: V) -> T: ...
    def setdefault(self: T, key: K, default: V) -> T: ...
    def delete(self: T, key: K) -> T: ...
    def key(self, index: int) -> K: ...
    def value(self, index: int) -> V: ...
    def item(self, index: int) -> Sequence[KV]: ...
    def __or__(self: T, other: Mapping[K, V]) -> T: ...
    def __reversed__(self) -> Iterator[K]: ...
    
    @classmethod
    def fromkeys(
        cls: Type[T], 
        seq: Iterable[K], 
        value: Optional[V] = None
    ) -> "frozendict[K, V]": ...

    # Blacklisted methods:
    def __setattr__(self, *a, **kw) -> NoReturn: ...
    def __delattr__(self, *a, **kw) -> NoReturn: ...


FrozenOrderedDict = frozendict
