from collections.abc import Hashable
from typing import Generic, NoReturn, TypeVar, overload, Type, Optional

try:
    from typing import Mapping, Sequence, Iterable, Iterator
except ImportError:
    from collections.abc import Mapping, Sequence, Iterable, Iterator

_K = TypeVar("_K", Hashable)
_V = TypeVar("_V")
_KV = TypeVar("_V", _K, _V)
_T = TypeVar("_T", Mapping[_K, _V])

def frozendict_or(
    self: Mapping[_K, _V], other: Mapping[_K, _V]
) -> "frozendict[_K, _V]": ...

class frozendict(Mapping[_K, _V], Generic[_K, _V]):
    # Fake __init__ to describe what __new__ does:
    @overload
    def __init__(self, **kwargs: _V) -> None: ...
    @overload
    def __init__(self, mapping: Mapping[_K, _V]) -> None: ...
    @overload
    def __init__(self, iterable: Iterable[Sequence[_KV]]) -> None: ...

    # Magic Methods:
    def __getitem__(self, __key: _K) -> _V: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[_K]: ...
    def __hash__(self) -> int: ...
    def __repr__(self) -> str: ...
    def copy(self: _T) -> _T: ...
    def __copy__(self: _T) -> _T: ...
    def __deepcopy__(self: _T) -> _T: ...
    # Omit __reduce__, its used for Pickle and we don't need the annotation in code.
    def set(self: _T, key: _K, value: _V) -> _T: ...
    def setdefault(self: _T, key: _K, default: _V) -> _T: ...
    def delete(self: _T, key: _K) -> _T: ...
    def key(self, index: int) -> _K: ...
    def value(self, index: int) -> _V: ...
    def item(self, index: int) -> Sequence[_KV]: ...
    def __or__(self: _T, other: Mapping[_K, _V]) -> _T: ...
    def __reversed__(self) -> Iterator[_K]: ...
    
    @classmethod
    def fromkeys(
        cls: Type[_T], 
        seq: Iterable[_K], 
        value: Optional[_V] = None
    ) -> _T: ...

    # Blacklisted methods:
    def __setattr__(self, *a, **kw) -> NoReturn: ...
    def __delattr__(self, *a, **kw) -> NoReturn: ...


FrozenOrderedDict = frozendict
